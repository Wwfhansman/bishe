<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Voice Interaction Test</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      display: flex;
      height: 100vh;
    }

    #sidebar {
      width: 250px;
      background: #f0f0f0;
      border-right: 1px solid #ddd;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }

    #main {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }

    h3 {
      margin-top: 0;
    }

    button {
      padding: 8px 12px;
      margin-right: 10px;
      cursor: pointer;
    }

    #sessionList {
      list-style: none;
      padding: 0;
      margin-top: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .session-item {
      padding: 10px;
      background: #fff;
      border: 1px solid #ddd;
      margin-bottom: 8px;
      cursor: pointer;
      border-radius: 4px;
    }

    .session-item:hover {
      background: #e0e0e0;
    }

    .session-item.active {
      border-color: #007bff;
      background: #e6f2ff;
    }

    .session-date {
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }

    .session-title {
      font-weight: bold;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #status {
      margin-top: 10px;
      color: #444;
    }

    #controls {
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <div id="sidebar">
    <button id="newChatBtn" style="width: 100%; margin-bottom: 10px;">+ 新对话</button>
    <div style="font-weight: bold; color: #666;">历史记录 (最近5条)</div>
    <ul id="sessionList"></ul>
  </div>

  <div id="main">
    <h3>语音交互测试</h3>
    <div id="controls">
      <button id="startBtn">开始监听</button>
      <button id="stopBtn" disabled>停止监听</button>
      <button id="probeBtn">探测TTS</button>
    </div>
    <div id="status">未连接</div>
    <pre id="log" style="flex: 1; overflow:auto; background:#f5f5f5; padding:8px; border:1px solid #ddd"></pre>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const sessionListEl = document.getElementById('sessionList');
    const newChatBtn = document.getElementById('newChatBtn');

    let ws = null;
    let audioCtx = null;
    let processor = null;
    let micStream = null;
    let inputSampleRate = 48000;
    let chunkMs = 200;
    let ttsSampleRate = 24000;
    let currentSessionId = null;
    let userId = localStorage.getItem('voice_user_id');

    if (!userId) {
      userId = 'user_' + Math.random().toString(36).substring(2, 15);
      localStorage.setItem('voice_user_id', userId);
    }

    function log(msg) { const el = document.getElementById('log'); el.textContent += (typeof msg === 'string' ? msg : JSON.stringify(msg)) + "\n"; el.scrollTop = el.scrollHeight; }

    // Fetch and display sessions
    async function loadSessions() {
      try {
        const res = await fetch(`/api/sessions?user_id=${userId}`);
        const data = await res.json();
        renderSessions(data.sessions);
      } catch (e) {
        console.error("Failed to load sessions", e);
      }
    }

    function renderSessions(sessions) {
      sessionListEl.innerHTML = '';
      sessions.forEach(s => {
        const li = document.createElement('li');
        li.className = 'session-item';
        if (s.id === currentSessionId) li.classList.add('active');

        const date = new Date(s.updated_at * 1000).toLocaleString();
        li.innerHTML = `
          <div class="session-date">${date}</div>
          <div class="session-title">${s.title || '新对话'}</div>
        `;
        li.onclick = () => selectSession(s.id);
        sessionListEl.appendChild(li);
      });
    }

    function selectSession(sid) {
      currentSessionId = sid;
      loadSessions(); // Re-render to update active state
      log(`Selected session: ${sid}`);
    }

    async function createSession() {
      try {
        const res = await fetch('/api/sessions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user_id: userId })
        });
        const data = await res.json();
        return data.session_id;
      } catch (e) {
        log("Error creating session: " + e);
        return null;
      }
    }

    newChatBtn.onclick = async () => {
      const sid = await createSession();
      if (sid) {
        selectSession(sid);
      }
    };

    // Initialize
    loadSessions();

    const pcmPlayer = (() => {
      let ctx = null;
      let node = null;
      let buffer = new Float32Array(0);
      let outRate = 48000;
      function init() {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        outRate = ctx.sampleRate;
        node = ctx.createScriptProcessor(4096, 1, 1);
        node.onaudioprocess = (e) => {
          const out = e.outputBuffer.getChannelData(0);
          const need = out.length;
          if (buffer.length >= need) {
            out.set(buffer.subarray(0, need));
            buffer = buffer.subarray(need);
          } else {
            out.fill(0);
          }
        };
        node.connect(ctx.destination);
      }
      function pushPCM16(chunk, inRate = 16000) {
        const int16 = new Int16Array(chunk.buffer, chunk.byteOffset, Math.floor(chunk.byteLength / 2));
        const f = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i++) f[i] = int16[i] / 32768;
        const ratio = outRate / inRate;
        const outLen = Math.floor(f.length * ratio);
        const out = new Float32Array(outLen);
        for (let i = 0; i < outLen; i++) {
          const srcPos = i / ratio;
          const idx = Math.floor(srcPos);
          const frac = srcPos - idx;
          const s0 = f[idx] || 0;
          const s1 = f[idx + 1] || s0;
          out[i] = s0 + (s1 - s0) * frac;
        }
        const merged = new Float32Array(buffer.length + out.length);
        merged.set(buffer, 0);
        merged.set(out, buffer.length);
        buffer = merged;
      }
      function reset() {
        buffer = new Float32Array(0);
      }
      return { init, pushPCM16, reset };
    })();

    async function start() {
      if (ws) return;

      // Ensure session exists
      if (!currentSessionId) {
        log("No session selected, creating new one...");
        currentSessionId = await createSession();
        if (!currentSessionId) return;
        loadSessions();
      }

      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true } });
      } catch (e) {
        statusEl.textContent = '麦克风权限被拒绝或不可用';
        return;
      }

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      inputSampleRate = audioCtx.sampleRate;
      const source = audioCtx.createMediaStreamSource(micStream);
      processor = audioCtx.createScriptProcessor(4096, 1, 1);
      let acc = [];
      let accSamples = 0;
      const targetSamples = Math.floor(16000 * chunkMs / 1000);
      processor.onaudioprocess = (e) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const input = e.inputBuffer.getChannelData(0);
        const ratio = 16000 / inputSampleRate;
        const outLen = Math.floor(input.length * ratio);
        const out = new Float32Array(outLen);
        for (let i = 0; i < outLen; i++) {
          const srcPos = i / ratio;
          const idx = Math.floor(srcPos);
          const frac = srcPos - idx;
          const s0 = input[idx] || 0;
          const s1 = input[idx + 1] || s0;
          out[i] = s0 + (s1 - s0) * frac;
        }
        acc.push(out);
        accSamples += out.length;
        if (accSamples >= targetSamples) {
          const merged = new Float32Array(accSamples);
          let off = 0;
          for (const a of acc) { merged.set(a, off); off += a.length; }
          acc = []; accSamples = 0;
          const int16 = new Int16Array(merged.length);
          for (let i = 0; i < merged.length; i++) {
            let s = Math.max(-1, Math.min(1, merged[i]));
            int16[i] = s < 0 ? s * 32768 : s * 32767;
          }
          ws.send(new Uint8Array(int16.buffer));
        }
      };
      source.connect(processor);
      processor.connect(audioCtx.destination);
      if (audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch (_) { } }

      log({ event: 'user_id', id: userId, session_id: currentSessionId });

      const origin = (window.location.origin && window.location.origin.startsWith('http')) ? window.location.origin : 'http://localhost:8000';
      const wsUrl = new URL('/ws/voice', origin);
      wsUrl.protocol = (wsUrl.protocol === 'https:') ? 'wss:' : 'ws:';
      wsUrl.searchParams.append('session_id', currentSessionId);
      ws = new WebSocket(wsUrl.href);
      ws.binaryType = 'arraybuffer';
      ws.onopen = () => { statusEl.textContent = '已连接，开始推流'; log({ event: 'ws_open' }); };
      ws.addEventListener('open', () => {
        try { ws.send(JSON.stringify({ cmd: 'init' })); } catch (_) { }
      });
      ws.onclose = () => { statusEl.textContent = '连接关闭'; };
      ws.onerror = () => { statusEl.textContent = '连接错误'; log({ event: 'ws_error' }); };
      ws.onmessage = (ev) => {
        if (typeof ev.data === 'string') {
          try {
            const o = JSON.parse(ev.data);
            if (o && o.event === 'tts_start' && typeof o.rate === 'number') {
              ttsSampleRate = o.rate;
            }
            log(o);
            if (o.event === 'llm_text' || o.event === 'tts_done') {
              loadSessions();
            }
          } catch (_) {
            log(ev.data);
          }
        } else {
          const arr = new Uint8Array(ev.data);
          pcmPlayer.pushPCM16(arr, ttsSampleRate);
        }
      };
      pcmPlayer.init();
      startBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stop() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ cmd: 'stop' }));
      }
      if (processor) { processor.disconnect(); processor = null; }
      if (audioCtx) { audioCtx.close(); audioCtx = null; }
      if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
      if (ws) { ws.close(); ws = null; }
      pcmPlayer.reset(); // Clear audio buffer to prevent stuttering
      startBtn.disabled = false;
      stopBtn.disabled = true;
      statusEl.textContent = '未连接';
    }

    startBtn.onclick = start;
    stopBtn.onclick = stop;
    document.getElementById('probeBtn').onclick = async () => {
      const origin = (window.location.origin && window.location.origin.startsWith('http')) ? window.location.origin : 'http://localhost:8000';
      const probeUrl = new URL('/api/tts_probe', origin);
      try {
        const r = await fetch(probeUrl.href);
        const j = await r.json();
        log(j);
      } catch (e) {
        log({ event: 'probe_error', detail: String(e) });
      }
    };
  </script>
</body>

</html>